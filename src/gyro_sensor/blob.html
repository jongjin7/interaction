<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Gyro Sensor</title>
    <style>
        *, *:before, *:after {
            box-sizing: border-box;
        }

        body {

            font-family: Arial, sans-serif;
            margin: 0;
            background-color: #f0f0f0;
        }

        h2 {
            margin: 0 0 20px;

        }

        canvas {
            margin: 5vw 5vw 0;

            width: 88vw; height: 80vh;
            box-shadow: 0.5vw 0.5vw 1vw rgba(0,0,0, 0.3)
        }
        .control{
            padding: 1vw 5vw;
        }

        .bubble {
            position: absolute;
            border-radius: 50%;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
    </style>
</head>
<body>



<canvas id="canvas"></canvas>
<div class="control">
    <label>볼 갯수: <input type="number" id="blobCount" value="10" min="1" max="100"></label>
    <label>점성도: <input type="range" id="viscosity" min="0.1" max="2" step="0.1" value="1"></label>
    <button onclick="start()">애니메이션 시작</button>
</div>

<script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    class Bubble {
        constructor(x, y, radius, color) {
            this.x = x;
            this.y = y;
            this.radius = radius;
            this.color = color;
            this.dy = Math.random() * 2 + 1; // 방울이 떨어지는 속도
        }

        update() {
            // 방울을 아래로 이동
            this.y += this.dy;
            // 화면을 벗어나면 방울 위치를 리셋
            if (this.y - this.radius > canvas.height) {
                this.y = -this.radius;
                this.x = Math.random() * canvas.width;
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();
        }
    }

    // 두 점 사이의 거리 계산
    function getDistance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // 색상 혼합 함수 (rgba 색상 값 기반)
    function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s, l];
    }

    function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function mixColors(color1, color2) {
        console.log('aa', color1, color2)
        const rgba1 = color1.match(/\d+/g).map(Number);
        const rgba2 = color2.match(/\d+/g).map(Number);

        // 색상을 평균내되 어둡고 투명하게 만듭니다.
        const r = Math.floor(((rgba1[0] + rgba2[0]) / 2) * 0.7); // 색상을 어둡게
        const g = Math.floor(((rgba1[1] + rgba2[1]) / 2) * 0.7); // 색상을 어둡게
        const b = Math.floor(((rgba1[2] + rgba2[2]) / 2) * 0.7); // 색상을 어둡게

        // 투명도를 랜덤으로 설정 (0.3에서 0.7 사이)
        const a = (Math.random() * 0.4 + 0.3).toFixed(2); // 알파 값을 0.3 ~ 0.7로 랜덤화

        return `rgba(${r}, ${g}, ${b}, ${a})`;
    }




    let bubbles = [];
    const bubbleCount = 40; // 방울 개수

    function init() {
        // 초기 방울들 생성
        bubbles = Array.from({ length: bubbleCount }, () =>
            new Bubble(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                15 + Math.random() * 10,
                `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, ${Math.random().toFixed(2)})`
            )
        );
    }

    function animate() {
        console.dir('현재 버블', bubbles.length)
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < bubbles.length; i++) {
            const bubbleA = bubbles[i];
            bubbleA.update(); // 방울 이동 업데이트
            bubbleA.draw();   // 방울 그리기

            // 인접한 방울들 확인하여 합치기
            for (let j = i + 1; j < bubbles.length; j++) {
                const bubbleB = bubbles[j];
                const distance = getDistance(bubbleA.x, bubbleA.y, bubbleB.x, bubbleB.y);
                const radiusSum = bubbleA.radius + bubbleB.radius; // 두 방울의 반지름 합

                if (distance < radiusSum) {
                    // 점성 효과를 위해 두 방울이 서로 빠르게 다가가도록 이동 (가속도 효과 추가)
                    bubbleA.x += (bubbleB.x - bubbleA.x) * 0.1;
                    bubbleA.y += (bubbleB.y - bubbleA.y) * 0.1;

                    // 충분히 가까워지면 방울 합치기
                    if (distance < radiusSum * 0.8) { // 더 가까워지면 합치기
                        const newX = (bubbleA.x + bubbleB.x) / 2;
                        const newY = (bubbleA.y + bubbleB.y) / 2;
                        const newRadius = Math.sqrt(bubbleA.radius ** 2 + bubbleB.radius ** 2); // 면적 기준으로 반지름 계산
                        //const newColor = mixColors(bubbleA.color, bubbleB.color); // 두 색상 혼합

                        // bubbleA의 위치와 속성 업데이트
                        bubbleA.x = newX;
                        bubbleA.y = newY;
                        bubbleA.radius = newRadius;
                        //bubbleA.color = newColor;

                        // bubbleB를 제거하고 반복 계속
                        bubbles.splice(j, 1);
                        j--;
                    }
                }
            }
        }

        requestAnimationFrame(animate);
    }

    init();
    animate();



</script>


</body>
</html>
