<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Gyro Sensor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: #f0f0f0;
        }

        h2 {
            margin: 0 0 20px;
        }

        .sensor-data {
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            z-index: 1;

        }

        .sensor-data > div {
            background-color: rgba(255, 255, 255, 0.2);
            text-align: center;
            padding: 20px;
            font-size: 1.2em;
            border-radius: 16px;
            box-shadow: 0 0 8px rgba(0,0,0, 0.2)
        }

        #permission-button {
            display: none;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 16px auto 0;
        }

        #fileInput {
            margin-top: 16px;
            width: 100px;
            height: 100px;
            border: 1px solid red;
        }

        canvas {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
<div class="sensor-data">
    <div>
        <h2>Gyro Sensor to RGB</h2>
        <div>Alpha (Z-axis): <span id="alpha">0</span>°</div>
        <div>Beta (X-axis): <span id="beta">0</span>°</div>
        <div>Gamma (Y-axis): <span id="gamma">0</span>°</div>
        <div>RGB Color: <span id="rgb">rgb(0, 0, 0)</span></div>
        <button id="permission-button">자이로센서 사용하기</button>
        <input type="file" id="fileInput" accept="image/*,video/*">
    </div>
</div>


<canvas id="canvas" width="640" height="480"></canvas>
<video muted autoplay playsinline loop></video>
<script>
    const fileInput = document.getElementById('fileInput');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.querySelector('video');
    video.style.position= 'absolute';
    video.style.border='1px solid red';
    video.style.top='0'
    video.style.left='0'
    video.style.width='100px'
    video.style.height='100px'
    let r = 0, g = 0, b = 0;  // RGB 값 저장
    let imgLoaded = false; // 이미지 로드 여부
    let currentImage = null; // 현재 이미지 저장
    let imageX = 0; // 이미지 X 위치
    let imageY = 0; // 이미지 Y 위치
    let lastGamma = 0; // 이전 gamma 값 저장
    let lastBeta = 0; // 이전 beta 값 저장

    // 포스터라이즈 단계를 정의
    const POSTERIZE_LEVELS = 5;

    // Function to set canvas size based on device resolution
    function setCanvasSize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    // Function to handle file input (image/video)
    function handleFileInput(event) {
        const file = event.target.files[0];
        const fileType = file.type;

        if (!file) return;

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (fileType.startsWith('image/')) {
            const img = new Image();
            const reader = new FileReader();
            reader.onload = function (e) {
                img.src = e.target.result;
                img.onload = function () {
                    imgLoaded = true;
                    currentImage = img; // Load image
                    imageX = 0;
                    imageY = 0;
                    drawImageWithPosterize(); // Draw initial image
                };
            };
            reader.readAsDataURL(file);
        } else if (fileType.startsWith('video/')) {
            const reader = new FileReader();
            reader.onload = function (e) {
                video.src = e.target.result;
                // video.load();
                // video.autoplay = true;
                // video.muted = true;  // 비디오 무음
                // video.loop = true;

                video.onloadeddata = function () {
                    imgLoaded = false; // 이미지 로드 상태 초기화
                    video.play().catch(error => {
                        console.log('Autoplay was prevented. Use a play button to start playback.');
                    });
                    drawVideoWithPosterize(); // 비디오 그리기 시작
                };

            };
            reader.readAsDataURL(file);
        } else {
            alert('지원하지 않는 파일 형식입니다.');
        }
    }

    // Function to draw image with posterize effect
    function drawImageWithPosterize() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (currentImage) {
            const { sourceX, sourceY, sourceWidth, sourceHeight, drawWidth, drawHeight } = getFitPosition(currentImage.width, currentImage.height, canvas.width, canvas.height);

            ctx.drawImage(
                currentImage,
                sourceX - imageX, sourceY - imageY, sourceWidth, sourceHeight,
                0, 0, drawWidth, drawHeight
            );
            applyPosterizeEffect();
        }
    }

    // Function to draw video with posterize effect
    function drawVideoWithPosterize() {
        function drawFrame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const { sourceX, sourceY, sourceWidth, sourceHeight, drawWidth, drawHeight } = getFitPosition(video.videoWidth, video.videoHeight, canvas.width, canvas.height);

            ctx.drawImage(
                video,
                sourceX, sourceY, sourceWidth, sourceHeight,
                0, 0, drawWidth, drawHeight
            );
            applyPosterizeEffect();
            requestAnimationFrame(drawFrame);  // 실시간 업데이트
        }
        video.play();
        drawFrame();
    }

    // Function to apply posterize effect and color overlay
    function applyPosterizeEffect() {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        // Posterize 효과 적용
        for (let i = 0; i < data.length; i += 4) {
            data[i] = posterize(data[i], POSTERIZE_LEVELS);     // Red
            data[i + 1] = posterize(data[i + 1], POSTERIZE_LEVELS); // Green
            data[i + 2] = posterize(data[i + 2], POSTERIZE_LEVELS); // Blue

            // 자이로센서로 변환된 색상 추가 (투명도 50%)
            data[i] = blendColor(data[i], r, 0.5);
            data[i + 1] = blendColor(data[i + 1], g, 0.5);
            data[i + 2] = blendColor(data[i + 2], b, 0.5);
        }

        ctx.putImageData(imageData, 0, 0);
    }

    // 포스터라이즈 효과 함수
    function posterize(value, levels) {
        const step = 255 / (levels - 1);
        return Math.round(value / step) * step;
    }

    // 색상을 혼합하는 함수
    function blendColor(baseColor, blendColor, blendFactor) {
        return Math.round(baseColor * (1 - blendFactor) + blendColor * blendFactor);
    }

    // Function to calculate fit position for image
    function getFitPosition(imageWidth, imageHeight, canvasWidth, canvasHeight) {
        const canvasRatio = canvasWidth / canvasHeight;
        const imageRatio = imageWidth / imageHeight;

        let sourceX, sourceY, sourceWidth, sourceHeight;
        let drawWidth, drawHeight;

        if (canvasRatio > imageRatio) {
            drawWidth = canvasWidth;
            drawHeight = canvasWidth / imageRatio;
            sourceWidth = imageWidth;
            sourceHeight = imageWidth / canvasRatio;
            sourceX = 0;
            sourceY = (imageHeight - sourceHeight) / 2;
        } else {
            drawHeight = canvasHeight;
            drawWidth = canvasHeight * imageRatio;
            sourceHeight = imageHeight;
            sourceWidth = imageHeight * canvasRatio;
            sourceY = 0;
            sourceX = (imageWidth - sourceWidth) / 2;
        }

        return { sourceX, sourceY, sourceWidth, sourceHeight, drawWidth, drawHeight };
    }



    // Gyro sensor handler function
    function handleOrientationEvent(event) {
        const alpha = event.alpha;
        const beta = event.beta;
        const gamma = event.gamma;

        // 이미지 위치 업데이트
        if (imgLoaded) {
            const gammaChange = Math.abs(gamma - lastGamma);
            const betaChange = Math.abs(beta - lastBeta);
            const totalChange = gammaChange + betaChange;

            // 최소 1px, 최대 10px로 움직임을 설정
            let movement = Math.max(1, Math.min(totalChange, 20));

            // X축과 Y축의 움직임을 계산
            imageX += (gamma - lastGamma) * movement; // X축
            imageY += (beta - lastBeta) * movement;   // Y축

            // 이미지가 캔버스를 벗어나지 않도록 제한
            const { sourceWidth, sourceHeight } = getFitPosition(currentImage.width, currentImage.height, canvas.width, canvas.height);
            imageX = Math.max(0, Math.min(imageX, currentImage.width - sourceWidth));
            imageY = Math.max(0, Math.min(imageY, currentImage.height - sourceHeight));

            drawImageWithPosterize(); // 이미지 다시 그리기
        }

        lastGamma = gamma; // 이전 gamma 값 업데이트
        lastBeta = beta;   // 이전 beta 값 업데이트
    }


    // Check if iOS (or other browsers requiring permission)
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        const permissionButton = document.getElementById('permission-button');
        permissionButton.style.display = 'block';

        permissionButton.addEventListener('click', function () {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientationEvent);
                        permissionButton.style.display = 'none'; // Hide button after granting permission
                    } else {
                        alert('Permission to access sensor was denied.');
                    }
                })
                .catch(console.error);
        });
    } else {
        // If no permission required, just add the event listener
        window.addEventListener('deviceorientation', handleOrientationEvent);
    }

    // Initialize canvas size
    setCanvasSize();
    window.addEventListener('resize', setCanvasSize); // Resize event
    fileInput.addEventListener('change', handleFileInput);
</script>


</body>
</html>
